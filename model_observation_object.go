/*
Marlowe Runtime REST API

REST API for Marlowe Runtime

API version: 0.0.5.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package marloweruntime

import (
	"encoding/json"
	"fmt"
)

// ObservationObject - A time-varying expression that evaluates to an integer
type ObservationObject struct {
	AndObject *AndObject
	ChooseForObject *ChooseForObject
	EqualObject *EqualObject
	GreaterObject *GreaterObject
	GreaterOrEqualObject *GreaterOrEqualObject
	LabelRef *LabelRef
	LesserObject *LesserObject
	LesserOrEqualObject *LesserOrEqualObject
	NotObject *NotObject
	OrObject *OrObject
	Bool *bool
}

// AndObjectAsObservationObject is a convenience function that returns AndObject wrapped in ObservationObject
func AndObjectAsObservationObject(v *AndObject) ObservationObject {
	return ObservationObject{
		AndObject: v,
	}
}

// ChooseForObjectAsObservationObject is a convenience function that returns ChooseForObject wrapped in ObservationObject
func ChooseForObjectAsObservationObject(v *ChooseForObject) ObservationObject {
	return ObservationObject{
		ChooseForObject: v,
	}
}

// EqualObjectAsObservationObject is a convenience function that returns EqualObject wrapped in ObservationObject
func EqualObjectAsObservationObject(v *EqualObject) ObservationObject {
	return ObservationObject{
		EqualObject: v,
	}
}

// GreaterObjectAsObservationObject is a convenience function that returns GreaterObject wrapped in ObservationObject
func GreaterObjectAsObservationObject(v *GreaterObject) ObservationObject {
	return ObservationObject{
		GreaterObject: v,
	}
}

// GreaterOrEqualObjectAsObservationObject is a convenience function that returns GreaterOrEqualObject wrapped in ObservationObject
func GreaterOrEqualObjectAsObservationObject(v *GreaterOrEqualObject) ObservationObject {
	return ObservationObject{
		GreaterOrEqualObject: v,
	}
}

// LabelRefAsObservationObject is a convenience function that returns LabelRef wrapped in ObservationObject
func LabelRefAsObservationObject(v *LabelRef) ObservationObject {
	return ObservationObject{
		LabelRef: v,
	}
}

// LesserObjectAsObservationObject is a convenience function that returns LesserObject wrapped in ObservationObject
func LesserObjectAsObservationObject(v *LesserObject) ObservationObject {
	return ObservationObject{
		LesserObject: v,
	}
}

// LesserOrEqualObjectAsObservationObject is a convenience function that returns LesserOrEqualObject wrapped in ObservationObject
func LesserOrEqualObjectAsObservationObject(v *LesserOrEqualObject) ObservationObject {
	return ObservationObject{
		LesserOrEqualObject: v,
	}
}

// NotObjectAsObservationObject is a convenience function that returns NotObject wrapped in ObservationObject
func NotObjectAsObservationObject(v *NotObject) ObservationObject {
	return ObservationObject{
		NotObject: v,
	}
}

// OrObjectAsObservationObject is a convenience function that returns OrObject wrapped in ObservationObject
func OrObjectAsObservationObject(v *OrObject) ObservationObject {
	return ObservationObject{
		OrObject: v,
	}
}

// boolAsObservationObject is a convenience function that returns bool wrapped in ObservationObject
func BoolAsObservationObject(v *bool) ObservationObject {
	return ObservationObject{
		Bool: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *ObservationObject) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into AndObject
	err = newStrictDecoder(data).Decode(&dst.AndObject)
	if err == nil {
		jsonAndObject, _ := json.Marshal(dst.AndObject)
		if string(jsonAndObject) == "{}" { // empty struct
			dst.AndObject = nil
		} else {
			match++
		}
	} else {
		dst.AndObject = nil
	}

	// try to unmarshal data into ChooseForObject
	err = newStrictDecoder(data).Decode(&dst.ChooseForObject)
	if err == nil {
		jsonChooseForObject, _ := json.Marshal(dst.ChooseForObject)
		if string(jsonChooseForObject) == "{}" { // empty struct
			dst.ChooseForObject = nil
		} else {
			match++
		}
	} else {
		dst.ChooseForObject = nil
	}

	// try to unmarshal data into EqualObject
	err = newStrictDecoder(data).Decode(&dst.EqualObject)
	if err == nil {
		jsonEqualObject, _ := json.Marshal(dst.EqualObject)
		if string(jsonEqualObject) == "{}" { // empty struct
			dst.EqualObject = nil
		} else {
			match++
		}
	} else {
		dst.EqualObject = nil
	}

	// try to unmarshal data into GreaterObject
	err = newStrictDecoder(data).Decode(&dst.GreaterObject)
	if err == nil {
		jsonGreaterObject, _ := json.Marshal(dst.GreaterObject)
		if string(jsonGreaterObject) == "{}" { // empty struct
			dst.GreaterObject = nil
		} else {
			match++
		}
	} else {
		dst.GreaterObject = nil
	}

	// try to unmarshal data into GreaterOrEqualObject
	err = newStrictDecoder(data).Decode(&dst.GreaterOrEqualObject)
	if err == nil {
		jsonGreaterOrEqualObject, _ := json.Marshal(dst.GreaterOrEqualObject)
		if string(jsonGreaterOrEqualObject) == "{}" { // empty struct
			dst.GreaterOrEqualObject = nil
		} else {
			match++
		}
	} else {
		dst.GreaterOrEqualObject = nil
	}

	// try to unmarshal data into LabelRef
	err = newStrictDecoder(data).Decode(&dst.LabelRef)
	if err == nil {
		jsonLabelRef, _ := json.Marshal(dst.LabelRef)
		if string(jsonLabelRef) == "{}" { // empty struct
			dst.LabelRef = nil
		} else {
			match++
		}
	} else {
		dst.LabelRef = nil
	}

	// try to unmarshal data into LesserObject
	err = newStrictDecoder(data).Decode(&dst.LesserObject)
	if err == nil {
		jsonLesserObject, _ := json.Marshal(dst.LesserObject)
		if string(jsonLesserObject) == "{}" { // empty struct
			dst.LesserObject = nil
		} else {
			match++
		}
	} else {
		dst.LesserObject = nil
	}

	// try to unmarshal data into LesserOrEqualObject
	err = newStrictDecoder(data).Decode(&dst.LesserOrEqualObject)
	if err == nil {
		jsonLesserOrEqualObject, _ := json.Marshal(dst.LesserOrEqualObject)
		if string(jsonLesserOrEqualObject) == "{}" { // empty struct
			dst.LesserOrEqualObject = nil
		} else {
			match++
		}
	} else {
		dst.LesserOrEqualObject = nil
	}

	// try to unmarshal data into NotObject
	err = newStrictDecoder(data).Decode(&dst.NotObject)
	if err == nil {
		jsonNotObject, _ := json.Marshal(dst.NotObject)
		if string(jsonNotObject) == "{}" { // empty struct
			dst.NotObject = nil
		} else {
			match++
		}
	} else {
		dst.NotObject = nil
	}

	// try to unmarshal data into OrObject
	err = newStrictDecoder(data).Decode(&dst.OrObject)
	if err == nil {
		jsonOrObject, _ := json.Marshal(dst.OrObject)
		if string(jsonOrObject) == "{}" { // empty struct
			dst.OrObject = nil
		} else {
			match++
		}
	} else {
		dst.OrObject = nil
	}

	// try to unmarshal data into Bool
	err = newStrictDecoder(data).Decode(&dst.Bool)
	if err == nil {
		jsonBool, _ := json.Marshal(dst.Bool)
		if string(jsonBool) == "{}" { // empty struct
			dst.Bool = nil
		} else {
			match++
		}
	} else {
		dst.Bool = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.AndObject = nil
		dst.ChooseForObject = nil
		dst.EqualObject = nil
		dst.GreaterObject = nil
		dst.GreaterOrEqualObject = nil
		dst.LabelRef = nil
		dst.LesserObject = nil
		dst.LesserOrEqualObject = nil
		dst.NotObject = nil
		dst.OrObject = nil
		dst.Bool = nil

		return fmt.Errorf("data matches more than one schema in oneOf(ObservationObject)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(ObservationObject)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src ObservationObject) MarshalJSON() ([]byte, error) {
	if src.AndObject != nil {
		return json.Marshal(&src.AndObject)
	}

	if src.ChooseForObject != nil {
		return json.Marshal(&src.ChooseForObject)
	}

	if src.EqualObject != nil {
		return json.Marshal(&src.EqualObject)
	}

	if src.GreaterObject != nil {
		return json.Marshal(&src.GreaterObject)
	}

	if src.GreaterOrEqualObject != nil {
		return json.Marshal(&src.GreaterOrEqualObject)
	}

	if src.LabelRef != nil {
		return json.Marshal(&src.LabelRef)
	}

	if src.LesserObject != nil {
		return json.Marshal(&src.LesserObject)
	}

	if src.LesserOrEqualObject != nil {
		return json.Marshal(&src.LesserOrEqualObject)
	}

	if src.NotObject != nil {
		return json.Marshal(&src.NotObject)
	}

	if src.OrObject != nil {
		return json.Marshal(&src.OrObject)
	}

	if src.Bool != nil {
		return json.Marshal(&src.Bool)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *ObservationObject) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.AndObject != nil {
		return obj.AndObject
	}

	if obj.ChooseForObject != nil {
		return obj.ChooseForObject
	}

	if obj.EqualObject != nil {
		return obj.EqualObject
	}

	if obj.GreaterObject != nil {
		return obj.GreaterObject
	}

	if obj.GreaterOrEqualObject != nil {
		return obj.GreaterOrEqualObject
	}

	if obj.LabelRef != nil {
		return obj.LabelRef
	}

	if obj.LesserObject != nil {
		return obj.LesserObject
	}

	if obj.LesserOrEqualObject != nil {
		return obj.LesserOrEqualObject
	}

	if obj.NotObject != nil {
		return obj.NotObject
	}

	if obj.OrObject != nil {
		return obj.OrObject
	}

	if obj.Bool != nil {
		return obj.Bool
	}

	// all schemas are nil
	return nil
}

type NullableObservationObject struct {
	value *ObservationObject
	isSet bool
}

func (v NullableObservationObject) Get() *ObservationObject {
	return v.value
}

func (v *NullableObservationObject) Set(val *ObservationObject) {
	v.value = val
	v.isSet = true
}

func (v NullableObservationObject) IsSet() bool {
	return v.isSet
}

func (v *NullableObservationObject) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableObservationObject(val *ObservationObject) *NullableObservationObject {
	return &NullableObservationObject{value: val, isSet: true}
}

func (v NullableObservationObject) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableObservationObject) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


