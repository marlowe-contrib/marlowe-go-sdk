/*
Marlowe Runtime REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 0.0.5
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type DefaultAPI interface {

	/*
	ContractsContractIdGet Method for ContractsContractIdGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@return ApiContractsContractIdGetRequest
	*/
	ContractsContractIdGet(ctx context.Context, contractId string) ApiContractsContractIdGetRequest

	// ContractsContractIdGetExecute executes the request
	//  @return ContractsContractIdGet200Response
	ContractsContractIdGetExecute(r ApiContractsContractIdGetRequest) (*ContractsContractIdGet200Response, *http.Response, error)

	/*
	ContractsContractIdNextGet Method for ContractsContractIdNextGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@return ApiContractsContractIdNextGetRequest
	*/
	ContractsContractIdNextGet(ctx context.Context, contractId string) ApiContractsContractIdNextGetRequest

	// ContractsContractIdNextGetExecute executes the request
	//  @return Next
	ContractsContractIdNextGetExecute(r ApiContractsContractIdNextGetRequest) (*Next, *http.Response, error)

	/*
	ContractsContractIdPut Method for ContractsContractIdPut

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@return ApiContractsContractIdPutRequest
	*/
	ContractsContractIdPut(ctx context.Context, contractId string) ApiContractsContractIdPutRequest

	// ContractsContractIdPutExecute executes the request
	ContractsContractIdPutExecute(r ApiContractsContractIdPutRequest) (*http.Response, error)

	/*
	ContractsContractIdTransactionsGet Method for ContractsContractIdTransactionsGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@return ApiContractsContractIdTransactionsGetRequest
	*/
	ContractsContractIdTransactionsGet(ctx context.Context, contractId string) ApiContractsContractIdTransactionsGetRequest

	// ContractsContractIdTransactionsGetExecute executes the request
	//  @return ListObjectTxHeader
	ContractsContractIdTransactionsGetExecute(r ApiContractsContractIdTransactionsGetRequest) (*ListObjectTxHeader, *http.Response, error)

	/*
	ContractsContractIdTransactionsPost Method for ContractsContractIdTransactionsPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@return ApiContractsContractIdTransactionsPostRequest
	*/
	ContractsContractIdTransactionsPost(ctx context.Context, contractId string) ApiContractsContractIdTransactionsPostRequest

	// ContractsContractIdTransactionsPostExecute executes the request
	//  @return ContractsContractIdTransactionsPost201Response
	ContractsContractIdTransactionsPostExecute(r ApiContractsContractIdTransactionsPostRequest) (*ContractsContractIdTransactionsPost201Response, *http.Response, error)

	/*
	ContractsContractIdTransactionsTransactionIdGet Method for ContractsContractIdTransactionsTransactionIdGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@param transactionId
	@return ApiContractsContractIdTransactionsTransactionIdGetRequest
	*/
	ContractsContractIdTransactionsTransactionIdGet(ctx context.Context, contractId string, transactionId string) ApiContractsContractIdTransactionsTransactionIdGetRequest

	// ContractsContractIdTransactionsTransactionIdGetExecute executes the request
	//  @return ContractsContractIdTransactionsTransactionIdGet200Response
	ContractsContractIdTransactionsTransactionIdGetExecute(r ApiContractsContractIdTransactionsTransactionIdGetRequest) (*ContractsContractIdTransactionsTransactionIdGet200Response, *http.Response, error)

	/*
	ContractsContractIdTransactionsTransactionIdPut Method for ContractsContractIdTransactionsTransactionIdPut

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@param transactionId
	@return ApiContractsContractIdTransactionsTransactionIdPutRequest
	*/
	ContractsContractIdTransactionsTransactionIdPut(ctx context.Context, contractId string, transactionId string) ApiContractsContractIdTransactionsTransactionIdPutRequest

	// ContractsContractIdTransactionsTransactionIdPutExecute executes the request
	ContractsContractIdTransactionsTransactionIdPutExecute(r ApiContractsContractIdTransactionsTransactionIdPutRequest) (*http.Response, error)

	/*
	ContractsGet Method for ContractsGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiContractsGetRequest
	*/
	ContractsGet(ctx context.Context) ApiContractsGetRequest

	// ContractsGetExecute executes the request
	//  @return ListObjectContractHeader
	ContractsGetExecute(r ApiContractsGetRequest) (*ListObjectContractHeader, *http.Response, error)

	/*
	ContractsPost Method for ContractsPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiContractsPostRequest
	*/
	ContractsPost(ctx context.Context) ApiContractsPostRequest

	// ContractsPostExecute executes the request
	//  @return ContractsPost201Response
	ContractsPostExecute(r ApiContractsPostRequest) (*ContractsPost201Response, *http.Response, error)

	/*
	ContractsSourcesContractSourceIdAdjacencyGet Method for ContractsSourcesContractSourceIdAdjacencyGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractSourceId
	@return ApiContractsSourcesContractSourceIdAdjacencyGetRequest
	*/
	ContractsSourcesContractSourceIdAdjacencyGet(ctx context.Context, contractSourceId string) ApiContractsSourcesContractSourceIdAdjacencyGetRequest

	// ContractsSourcesContractSourceIdAdjacencyGetExecute executes the request
	//  @return ListObjectContractSourceId
	ContractsSourcesContractSourceIdAdjacencyGetExecute(r ApiContractsSourcesContractSourceIdAdjacencyGetRequest) (*ListObjectContractSourceId, *http.Response, error)

	/*
	ContractsSourcesContractSourceIdClosureGet Method for ContractsSourcesContractSourceIdClosureGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractSourceId
	@return ApiContractsSourcesContractSourceIdClosureGetRequest
	*/
	ContractsSourcesContractSourceIdClosureGet(ctx context.Context, contractSourceId string) ApiContractsSourcesContractSourceIdClosureGetRequest

	// ContractsSourcesContractSourceIdClosureGetExecute executes the request
	//  @return ListObjectContractSourceId
	ContractsSourcesContractSourceIdClosureGetExecute(r ApiContractsSourcesContractSourceIdClosureGetRequest) (*ListObjectContractSourceId, *http.Response, error)

	/*
	ContractsSourcesContractSourceIdGet Method for ContractsSourcesContractSourceIdGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractSourceId
	@return ApiContractsSourcesContractSourceIdGetRequest
	*/
	ContractsSourcesContractSourceIdGet(ctx context.Context, contractSourceId string) ApiContractsSourcesContractSourceIdGetRequest

	// ContractsSourcesContractSourceIdGetExecute executes the request
	//  @return Contract
	ContractsSourcesContractSourceIdGetExecute(r ApiContractsSourcesContractSourceIdGetRequest) (*Contract, *http.Response, error)

	/*
	ContractsSourcesPost Method for ContractsSourcesPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiContractsSourcesPostRequest
	*/
	ContractsSourcesPost(ctx context.Context) ApiContractsSourcesPostRequest

	// ContractsSourcesPostExecute executes the request
	//  @return PostContractSourceResponse
	ContractsSourcesPostExecute(r ApiContractsSourcesPostRequest) (*PostContractSourceResponse, *http.Response, error)

	/*
	HealthcheckGet Method for HealthcheckGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiHealthcheckGetRequest
	*/
	HealthcheckGet(ctx context.Context) ApiHealthcheckGetRequest

	// HealthcheckGetExecute executes the request
	HealthcheckGetExecute(r ApiHealthcheckGetRequest) (*http.Response, error)

	/*
	PayoutsGet Method for PayoutsGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPayoutsGetRequest
	*/
	PayoutsGet(ctx context.Context) ApiPayoutsGetRequest

	// PayoutsGetExecute executes the request
	//  @return ListObjectPayoutHeader
	PayoutsGetExecute(r ApiPayoutsGetRequest) (*ListObjectPayoutHeader, *http.Response, error)

	/*
	PayoutsPayoutIdGet Method for PayoutsPayoutIdGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param payoutId
	@return ApiPayoutsPayoutIdGetRequest
	*/
	PayoutsPayoutIdGet(ctx context.Context, payoutId string) ApiPayoutsPayoutIdGetRequest

	// PayoutsPayoutIdGetExecute executes the request
	//  @return PayoutsPayoutIdGet200Response
	PayoutsPayoutIdGetExecute(r ApiPayoutsPayoutIdGetRequest) (*PayoutsPayoutIdGet200Response, *http.Response, error)

	/*
	WithdrawalsGet Method for WithdrawalsGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWithdrawalsGetRequest
	*/
	WithdrawalsGet(ctx context.Context) ApiWithdrawalsGetRequest

	// WithdrawalsGetExecute executes the request
	//  @return ListObjectWithdrawalHeader
	WithdrawalsGetExecute(r ApiWithdrawalsGetRequest) (*ListObjectWithdrawalHeader, *http.Response, error)

	/*
	WithdrawalsPost Method for WithdrawalsPost

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWithdrawalsPostRequest
	*/
	WithdrawalsPost(ctx context.Context) ApiWithdrawalsPostRequest

	// WithdrawalsPostExecute executes the request
	//  @return WithdrawalsPost201Response
	WithdrawalsPostExecute(r ApiWithdrawalsPostRequest) (*WithdrawalsPost201Response, *http.Response, error)

	/*
	WithdrawalsWithdrawalIdGet Method for WithdrawalsWithdrawalIdGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param withdrawalId
	@return ApiWithdrawalsWithdrawalIdGetRequest
	*/
	WithdrawalsWithdrawalIdGet(ctx context.Context, withdrawalId string) ApiWithdrawalsWithdrawalIdGetRequest

	// WithdrawalsWithdrawalIdGetExecute executes the request
	//  @return Withdrawal
	WithdrawalsWithdrawalIdGetExecute(r ApiWithdrawalsWithdrawalIdGetRequest) (*Withdrawal, *http.Response, error)

	/*
	WithdrawalsWithdrawalIdPut Method for WithdrawalsWithdrawalIdPut

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param withdrawalId
	@return ApiWithdrawalsWithdrawalIdPutRequest
	*/
	WithdrawalsWithdrawalIdPut(ctx context.Context, withdrawalId string) ApiWithdrawalsWithdrawalIdPutRequest

	// WithdrawalsWithdrawalIdPutExecute executes the request
	WithdrawalsWithdrawalIdPutExecute(r ApiWithdrawalsWithdrawalIdPutRequest) (*http.Response, error)
}

// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiContractsContractIdGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractId string
}

func (r ApiContractsContractIdGetRequest) Execute() (*ContractsContractIdGet200Response, *http.Response, error) {
	return r.ApiService.ContractsContractIdGetExecute(r)
}

/*
ContractsContractIdGet Method for ContractsContractIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @return ApiContractsContractIdGetRequest
*/
func (a *DefaultAPIService) ContractsContractIdGet(ctx context.Context, contractId string) ApiContractsContractIdGetRequest {
	return ApiContractsContractIdGetRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
	}
}

// Execute executes the request
//  @return ContractsContractIdGet200Response
func (a *DefaultAPIService) ContractsContractIdGetExecute(r ApiContractsContractIdGetRequest) (*ContractsContractIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractsContractIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ContractsContractIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contractId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiContractsContractIdNextGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractId string
	validityStart *string
	validityEnd *string
	party *[]string
}

func (r ApiContractsContractIdNextGetRequest) ValidityStart(validityStart string) ApiContractsContractIdNextGetRequest {
	r.validityStart = &validityStart
	return r
}

func (r ApiContractsContractIdNextGetRequest) ValidityEnd(validityEnd string) ApiContractsContractIdNextGetRequest {
	r.validityEnd = &validityEnd
	return r
}

func (r ApiContractsContractIdNextGetRequest) Party(party []string) ApiContractsContractIdNextGetRequest {
	r.party = &party
	return r
}

func (r ApiContractsContractIdNextGetRequest) Execute() (*Next, *http.Response, error) {
	return r.ApiService.ContractsContractIdNextGetExecute(r)
}

/*
ContractsContractIdNextGet Method for ContractsContractIdNextGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @return ApiContractsContractIdNextGetRequest
*/
func (a *DefaultAPIService) ContractsContractIdNextGet(ctx context.Context, contractId string) ApiContractsContractIdNextGetRequest {
	return ApiContractsContractIdNextGetRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
	}
}

// Execute executes the request
//  @return Next
func (a *DefaultAPIService) ContractsContractIdNextGetExecute(r ApiContractsContractIdNextGetRequest) (*Next, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Next
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ContractsContractIdNextGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contractId}/next"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.validityStart == nil {
		return localVarReturnValue, nil, reportError("validityStart is required and must be specified")
	}
	if r.validityEnd == nil {
		return localVarReturnValue, nil, reportError("validityEnd is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "validityStart", r.validityStart, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "validityEnd", r.validityEnd, "")
	if r.party != nil {
		t := *r.party
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "party", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "party", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiContractsContractIdPutRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractId string
	textEnvelope *TextEnvelope
}

func (r ApiContractsContractIdPutRequest) TextEnvelope(textEnvelope TextEnvelope) ApiContractsContractIdPutRequest {
	r.textEnvelope = &textEnvelope
	return r
}

func (r ApiContractsContractIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ContractsContractIdPutExecute(r)
}

/*
ContractsContractIdPut Method for ContractsContractIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @return ApiContractsContractIdPutRequest
*/
func (a *DefaultAPIService) ContractsContractIdPut(ctx context.Context, contractId string) ApiContractsContractIdPutRequest {
	return ApiContractsContractIdPutRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ContractsContractIdPutExecute(r ApiContractsContractIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ContractsContractIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contractId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.textEnvelope
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiContractsContractIdTransactionsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractId string
	range_ *string
}

func (r ApiContractsContractIdTransactionsGetRequest) Range_(range_ string) ApiContractsContractIdTransactionsGetRequest {
	r.range_ = &range_
	return r
}

func (r ApiContractsContractIdTransactionsGetRequest) Execute() (*ListObjectTxHeader, *http.Response, error) {
	return r.ApiService.ContractsContractIdTransactionsGetExecute(r)
}

/*
ContractsContractIdTransactionsGet Method for ContractsContractIdTransactionsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @return ApiContractsContractIdTransactionsGetRequest
*/
func (a *DefaultAPIService) ContractsContractIdTransactionsGet(ctx context.Context, contractId string) ApiContractsContractIdTransactionsGetRequest {
	return ApiContractsContractIdTransactionsGetRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
	}
}

// Execute executes the request
//  @return ListObjectTxHeader
func (a *DefaultAPIService) ContractsContractIdTransactionsGetExecute(r ApiContractsContractIdTransactionsGetRequest) (*ListObjectTxHeader, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListObjectTxHeader
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ContractsContractIdTransactionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contractId}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Range", r.range_, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiContractsContractIdTransactionsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractId string
	xChangeAddress *string
	xAddress *string
	xCollateralUTxO *string
	postTransactionsRequest *PostTransactionsRequest
}

func (r ApiContractsContractIdTransactionsPostRequest) XChangeAddress(xChangeAddress string) ApiContractsContractIdTransactionsPostRequest {
	r.xChangeAddress = &xChangeAddress
	return r
}

func (r ApiContractsContractIdTransactionsPostRequest) XAddress(xAddress string) ApiContractsContractIdTransactionsPostRequest {
	r.xAddress = &xAddress
	return r
}

func (r ApiContractsContractIdTransactionsPostRequest) XCollateralUTxO(xCollateralUTxO string) ApiContractsContractIdTransactionsPostRequest {
	r.xCollateralUTxO = &xCollateralUTxO
	return r
}

func (r ApiContractsContractIdTransactionsPostRequest) PostTransactionsRequest(postTransactionsRequest PostTransactionsRequest) ApiContractsContractIdTransactionsPostRequest {
	r.postTransactionsRequest = &postTransactionsRequest
	return r
}

func (r ApiContractsContractIdTransactionsPostRequest) Execute() (*ContractsContractIdTransactionsPost201Response, *http.Response, error) {
	return r.ApiService.ContractsContractIdTransactionsPostExecute(r)
}

/*
ContractsContractIdTransactionsPost Method for ContractsContractIdTransactionsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @return ApiContractsContractIdTransactionsPostRequest
*/
func (a *DefaultAPIService) ContractsContractIdTransactionsPost(ctx context.Context, contractId string) ApiContractsContractIdTransactionsPostRequest {
	return ApiContractsContractIdTransactionsPostRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
	}
}

// Execute executes the request
//  @return ContractsContractIdTransactionsPost201Response
func (a *DefaultAPIService) ContractsContractIdTransactionsPostExecute(r ApiContractsContractIdTransactionsPostRequest) (*ContractsContractIdTransactionsPost201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractsContractIdTransactionsPost201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ContractsContractIdTransactionsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contractId}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xChangeAddress == nil {
		return localVarReturnValue, nil, reportError("xChangeAddress is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vendor.iog.marlowe-runtime.apply-inputs-tx-json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Change-Address", r.xChangeAddress, "")
	if r.xAddress != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Address", r.xAddress, "")
	}
	if r.xCollateralUTxO != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Collateral-UTxO", r.xCollateralUTxO, "")
	}
	// body params
	localVarPostBody = r.postTransactionsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiContractsContractIdTransactionsTransactionIdGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractId string
	transactionId string
}

func (r ApiContractsContractIdTransactionsTransactionIdGetRequest) Execute() (*ContractsContractIdTransactionsTransactionIdGet200Response, *http.Response, error) {
	return r.ApiService.ContractsContractIdTransactionsTransactionIdGetExecute(r)
}

/*
ContractsContractIdTransactionsTransactionIdGet Method for ContractsContractIdTransactionsTransactionIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @param transactionId
 @return ApiContractsContractIdTransactionsTransactionIdGetRequest
*/
func (a *DefaultAPIService) ContractsContractIdTransactionsTransactionIdGet(ctx context.Context, contractId string, transactionId string) ApiContractsContractIdTransactionsTransactionIdGetRequest {
	return ApiContractsContractIdTransactionsTransactionIdGetRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
		transactionId: transactionId,
	}
}

// Execute executes the request
//  @return ContractsContractIdTransactionsTransactionIdGet200Response
func (a *DefaultAPIService) ContractsContractIdTransactionsTransactionIdGetExecute(r ApiContractsContractIdTransactionsTransactionIdGetRequest) (*ContractsContractIdTransactionsTransactionIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractsContractIdTransactionsTransactionIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ContractsContractIdTransactionsTransactionIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contractId}/transactions/{transactionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiContractsContractIdTransactionsTransactionIdPutRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractId string
	transactionId string
	textEnvelope *TextEnvelope
}

func (r ApiContractsContractIdTransactionsTransactionIdPutRequest) TextEnvelope(textEnvelope TextEnvelope) ApiContractsContractIdTransactionsTransactionIdPutRequest {
	r.textEnvelope = &textEnvelope
	return r
}

func (r ApiContractsContractIdTransactionsTransactionIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ContractsContractIdTransactionsTransactionIdPutExecute(r)
}

/*
ContractsContractIdTransactionsTransactionIdPut Method for ContractsContractIdTransactionsTransactionIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @param transactionId
 @return ApiContractsContractIdTransactionsTransactionIdPutRequest
*/
func (a *DefaultAPIService) ContractsContractIdTransactionsTransactionIdPut(ctx context.Context, contractId string, transactionId string) ApiContractsContractIdTransactionsTransactionIdPutRequest {
	return ApiContractsContractIdTransactionsTransactionIdPutRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
		transactionId: transactionId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ContractsContractIdTransactionsTransactionIdPutExecute(r ApiContractsContractIdTransactionsTransactionIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ContractsContractIdTransactionsTransactionIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contractId}/transactions/{transactionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.textEnvelope
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiContractsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	roleCurrency *[]string
	tag *[]string
	partyAddress *[]string
	partyRole *[]string
	range_ *string
}

func (r ApiContractsGetRequest) RoleCurrency(roleCurrency []string) ApiContractsGetRequest {
	r.roleCurrency = &roleCurrency
	return r
}

func (r ApiContractsGetRequest) Tag(tag []string) ApiContractsGetRequest {
	r.tag = &tag
	return r
}

func (r ApiContractsGetRequest) PartyAddress(partyAddress []string) ApiContractsGetRequest {
	r.partyAddress = &partyAddress
	return r
}

func (r ApiContractsGetRequest) PartyRole(partyRole []string) ApiContractsGetRequest {
	r.partyRole = &partyRole
	return r
}

func (r ApiContractsGetRequest) Range_(range_ string) ApiContractsGetRequest {
	r.range_ = &range_
	return r
}

func (r ApiContractsGetRequest) Execute() (*ListObjectContractHeader, *http.Response, error) {
	return r.ApiService.ContractsGetExecute(r)
}

/*
ContractsGet Method for ContractsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiContractsGetRequest
*/
func (a *DefaultAPIService) ContractsGet(ctx context.Context) ApiContractsGetRequest {
	return ApiContractsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListObjectContractHeader
func (a *DefaultAPIService) ContractsGetExecute(r ApiContractsGetRequest) (*ListObjectContractHeader, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListObjectContractHeader
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ContractsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.roleCurrency != nil {
		t := *r.roleCurrency
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roleCurrency", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roleCurrency", t, "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.partyAddress != nil {
		t := *r.partyAddress
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "partyAddress", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "partyAddress", t, "multi")
		}
	}
	if r.partyRole != nil {
		t := *r.partyRole
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "partyRole", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "partyRole", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Range", r.range_, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiContractsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	xChangeAddress *string
	xStakeAddress *string
	xAddress *string
	xCollateralUTxO *string
	postContractsRequest *PostContractsRequest
}

func (r ApiContractsPostRequest) XChangeAddress(xChangeAddress string) ApiContractsPostRequest {
	r.xChangeAddress = &xChangeAddress
	return r
}

func (r ApiContractsPostRequest) XStakeAddress(xStakeAddress string) ApiContractsPostRequest {
	r.xStakeAddress = &xStakeAddress
	return r
}

func (r ApiContractsPostRequest) XAddress(xAddress string) ApiContractsPostRequest {
	r.xAddress = &xAddress
	return r
}

func (r ApiContractsPostRequest) XCollateralUTxO(xCollateralUTxO string) ApiContractsPostRequest {
	r.xCollateralUTxO = &xCollateralUTxO
	return r
}

func (r ApiContractsPostRequest) PostContractsRequest(postContractsRequest PostContractsRequest) ApiContractsPostRequest {
	r.postContractsRequest = &postContractsRequest
	return r
}

func (r ApiContractsPostRequest) Execute() (*ContractsPost201Response, *http.Response, error) {
	return r.ApiService.ContractsPostExecute(r)
}

/*
ContractsPost Method for ContractsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiContractsPostRequest
*/
func (a *DefaultAPIService) ContractsPost(ctx context.Context) ApiContractsPostRequest {
	return ApiContractsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ContractsPost201Response
func (a *DefaultAPIService) ContractsPostExecute(r ApiContractsPostRequest) (*ContractsPost201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractsPost201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ContractsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xChangeAddress == nil {
		return localVarReturnValue, nil, reportError("xChangeAddress is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vendor.iog.marlowe-runtime.contract-tx-json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xStakeAddress != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Stake-Address", r.xStakeAddress, "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Change-Address", r.xChangeAddress, "")
	if r.xAddress != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Address", r.xAddress, "")
	}
	if r.xCollateralUTxO != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Collateral-UTxO", r.xCollateralUTxO, "")
	}
	// body params
	localVarPostBody = r.postContractsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiContractsSourcesContractSourceIdAdjacencyGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractSourceId string
}

func (r ApiContractsSourcesContractSourceIdAdjacencyGetRequest) Execute() (*ListObjectContractSourceId, *http.Response, error) {
	return r.ApiService.ContractsSourcesContractSourceIdAdjacencyGetExecute(r)
}

/*
ContractsSourcesContractSourceIdAdjacencyGet Method for ContractsSourcesContractSourceIdAdjacencyGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractSourceId
 @return ApiContractsSourcesContractSourceIdAdjacencyGetRequest
*/
func (a *DefaultAPIService) ContractsSourcesContractSourceIdAdjacencyGet(ctx context.Context, contractSourceId string) ApiContractsSourcesContractSourceIdAdjacencyGetRequest {
	return ApiContractsSourcesContractSourceIdAdjacencyGetRequest{
		ApiService: a,
		ctx: ctx,
		contractSourceId: contractSourceId,
	}
}

// Execute executes the request
//  @return ListObjectContractSourceId
func (a *DefaultAPIService) ContractsSourcesContractSourceIdAdjacencyGetExecute(r ApiContractsSourcesContractSourceIdAdjacencyGetRequest) (*ListObjectContractSourceId, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListObjectContractSourceId
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ContractsSourcesContractSourceIdAdjacencyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/sources/{contractSourceId}/adjacency"
	localVarPath = strings.Replace(localVarPath, "{"+"contractSourceId"+"}", url.PathEscape(parameterValueToString(r.contractSourceId, "contractSourceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiContractsSourcesContractSourceIdClosureGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractSourceId string
}

func (r ApiContractsSourcesContractSourceIdClosureGetRequest) Execute() (*ListObjectContractSourceId, *http.Response, error) {
	return r.ApiService.ContractsSourcesContractSourceIdClosureGetExecute(r)
}

/*
ContractsSourcesContractSourceIdClosureGet Method for ContractsSourcesContractSourceIdClosureGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractSourceId
 @return ApiContractsSourcesContractSourceIdClosureGetRequest
*/
func (a *DefaultAPIService) ContractsSourcesContractSourceIdClosureGet(ctx context.Context, contractSourceId string) ApiContractsSourcesContractSourceIdClosureGetRequest {
	return ApiContractsSourcesContractSourceIdClosureGetRequest{
		ApiService: a,
		ctx: ctx,
		contractSourceId: contractSourceId,
	}
}

// Execute executes the request
//  @return ListObjectContractSourceId
func (a *DefaultAPIService) ContractsSourcesContractSourceIdClosureGetExecute(r ApiContractsSourcesContractSourceIdClosureGetRequest) (*ListObjectContractSourceId, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListObjectContractSourceId
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ContractsSourcesContractSourceIdClosureGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/sources/{contractSourceId}/closure"
	localVarPath = strings.Replace(localVarPath, "{"+"contractSourceId"+"}", url.PathEscape(parameterValueToString(r.contractSourceId, "contractSourceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiContractsSourcesContractSourceIdGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractSourceId string
	expand *bool
}

func (r ApiContractsSourcesContractSourceIdGetRequest) Expand(expand bool) ApiContractsSourcesContractSourceIdGetRequest {
	r.expand = &expand
	return r
}

func (r ApiContractsSourcesContractSourceIdGetRequest) Execute() (*Contract, *http.Response, error) {
	return r.ApiService.ContractsSourcesContractSourceIdGetExecute(r)
}

/*
ContractsSourcesContractSourceIdGet Method for ContractsSourcesContractSourceIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractSourceId
 @return ApiContractsSourcesContractSourceIdGetRequest
*/
func (a *DefaultAPIService) ContractsSourcesContractSourceIdGet(ctx context.Context, contractSourceId string) ApiContractsSourcesContractSourceIdGetRequest {
	return ApiContractsSourcesContractSourceIdGetRequest{
		ApiService: a,
		ctx: ctx,
		contractSourceId: contractSourceId,
	}
}

// Execute executes the request
//  @return Contract
func (a *DefaultAPIService) ContractsSourcesContractSourceIdGetExecute(r ApiContractsSourcesContractSourceIdGetRequest) (*Contract, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Contract
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ContractsSourcesContractSourceIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/sources/{contractSourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contractSourceId"+"}", url.PathEscape(parameterValueToString(r.contractSourceId, "contractSourceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	} else {
		var defaultValue bool = false
		r.expand = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiContractsSourcesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	main *string
	labelledObject *[]LabelledObject
}

func (r ApiContractsSourcesPostRequest) Main(main string) ApiContractsSourcesPostRequest {
	r.main = &main
	return r
}

func (r ApiContractsSourcesPostRequest) LabelledObject(labelledObject []LabelledObject) ApiContractsSourcesPostRequest {
	r.labelledObject = &labelledObject
	return r
}

func (r ApiContractsSourcesPostRequest) Execute() (*PostContractSourceResponse, *http.Response, error) {
	return r.ApiService.ContractsSourcesPostExecute(r)
}

/*
ContractsSourcesPost Method for ContractsSourcesPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiContractsSourcesPostRequest
*/
func (a *DefaultAPIService) ContractsSourcesPost(ctx context.Context) ApiContractsSourcesPostRequest {
	return ApiContractsSourcesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostContractSourceResponse
func (a *DefaultAPIService) ContractsSourcesPostExecute(r ApiContractsSourcesPostRequest) (*PostContractSourceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostContractSourceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ContractsSourcesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/sources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.main == nil {
		return localVarReturnValue, nil, reportError("main is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "main", r.main, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.labelledObject
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHealthcheckGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiHealthcheckGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.HealthcheckGetExecute(r)
}

/*
HealthcheckGet Method for HealthcheckGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHealthcheckGetRequest
*/
func (a *DefaultAPIService) HealthcheckGet(ctx context.Context) ApiHealthcheckGetRequest {
	return ApiHealthcheckGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) HealthcheckGetExecute(r ApiHealthcheckGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.HealthcheckGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/healthcheck"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPayoutsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractId *[]string
	roleToken *[]string
	status *string
	range_ *string
}

func (r ApiPayoutsGetRequest) ContractId(contractId []string) ApiPayoutsGetRequest {
	r.contractId = &contractId
	return r
}

func (r ApiPayoutsGetRequest) RoleToken(roleToken []string) ApiPayoutsGetRequest {
	r.roleToken = &roleToken
	return r
}

func (r ApiPayoutsGetRequest) Status(status string) ApiPayoutsGetRequest {
	r.status = &status
	return r
}

func (r ApiPayoutsGetRequest) Range_(range_ string) ApiPayoutsGetRequest {
	r.range_ = &range_
	return r
}

func (r ApiPayoutsGetRequest) Execute() (*ListObjectPayoutHeader, *http.Response, error) {
	return r.ApiService.PayoutsGetExecute(r)
}

/*
PayoutsGet Method for PayoutsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPayoutsGetRequest
*/
func (a *DefaultAPIService) PayoutsGet(ctx context.Context) ApiPayoutsGetRequest {
	return ApiPayoutsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListObjectPayoutHeader
func (a *DefaultAPIService) PayoutsGetExecute(r ApiPayoutsGetRequest) (*ListObjectPayoutHeader, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListObjectPayoutHeader
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PayoutsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contractId != nil {
		t := *r.contractId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contractId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contractId", t, "multi")
		}
	}
	if r.roleToken != nil {
		t := *r.roleToken
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roleToken", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roleToken", t, "multi")
		}
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Range", r.range_, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPayoutsPayoutIdGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	payoutId string
}

func (r ApiPayoutsPayoutIdGetRequest) Execute() (*PayoutsPayoutIdGet200Response, *http.Response, error) {
	return r.ApiService.PayoutsPayoutIdGetExecute(r)
}

/*
PayoutsPayoutIdGet Method for PayoutsPayoutIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param payoutId
 @return ApiPayoutsPayoutIdGetRequest
*/
func (a *DefaultAPIService) PayoutsPayoutIdGet(ctx context.Context, payoutId string) ApiPayoutsPayoutIdGetRequest {
	return ApiPayoutsPayoutIdGetRequest{
		ApiService: a,
		ctx: ctx,
		payoutId: payoutId,
	}
}

// Execute executes the request
//  @return PayoutsPayoutIdGet200Response
func (a *DefaultAPIService) PayoutsPayoutIdGetExecute(r ApiPayoutsPayoutIdGetRequest) (*PayoutsPayoutIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PayoutsPayoutIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.PayoutsPayoutIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts/{payoutId}"
	localVarPath = strings.Replace(localVarPath, "{"+"payoutId"+"}", url.PathEscape(parameterValueToString(r.payoutId, "payoutId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWithdrawalsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	roleCurrency *[]string
	range_ *string
}

func (r ApiWithdrawalsGetRequest) RoleCurrency(roleCurrency []string) ApiWithdrawalsGetRequest {
	r.roleCurrency = &roleCurrency
	return r
}

func (r ApiWithdrawalsGetRequest) Range_(range_ string) ApiWithdrawalsGetRequest {
	r.range_ = &range_
	return r
}

func (r ApiWithdrawalsGetRequest) Execute() (*ListObjectWithdrawalHeader, *http.Response, error) {
	return r.ApiService.WithdrawalsGetExecute(r)
}

/*
WithdrawalsGet Method for WithdrawalsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWithdrawalsGetRequest
*/
func (a *DefaultAPIService) WithdrawalsGet(ctx context.Context) ApiWithdrawalsGetRequest {
	return ApiWithdrawalsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListObjectWithdrawalHeader
func (a *DefaultAPIService) WithdrawalsGetExecute(r ApiWithdrawalsGetRequest) (*ListObjectWithdrawalHeader, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListObjectWithdrawalHeader
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.WithdrawalsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/withdrawals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.roleCurrency != nil {
		t := *r.roleCurrency
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roleCurrency", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roleCurrency", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Range", r.range_, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWithdrawalsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	xChangeAddress *string
	xAddress *string
	xCollateralUTxO *string
	postWithdrawalsRequest *PostWithdrawalsRequest
}

func (r ApiWithdrawalsPostRequest) XChangeAddress(xChangeAddress string) ApiWithdrawalsPostRequest {
	r.xChangeAddress = &xChangeAddress
	return r
}

func (r ApiWithdrawalsPostRequest) XAddress(xAddress string) ApiWithdrawalsPostRequest {
	r.xAddress = &xAddress
	return r
}

func (r ApiWithdrawalsPostRequest) XCollateralUTxO(xCollateralUTxO string) ApiWithdrawalsPostRequest {
	r.xCollateralUTxO = &xCollateralUTxO
	return r
}

func (r ApiWithdrawalsPostRequest) PostWithdrawalsRequest(postWithdrawalsRequest PostWithdrawalsRequest) ApiWithdrawalsPostRequest {
	r.postWithdrawalsRequest = &postWithdrawalsRequest
	return r
}

func (r ApiWithdrawalsPostRequest) Execute() (*WithdrawalsPost201Response, *http.Response, error) {
	return r.ApiService.WithdrawalsPostExecute(r)
}

/*
WithdrawalsPost Method for WithdrawalsPost

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWithdrawalsPostRequest
*/
func (a *DefaultAPIService) WithdrawalsPost(ctx context.Context) ApiWithdrawalsPostRequest {
	return ApiWithdrawalsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WithdrawalsPost201Response
func (a *DefaultAPIService) WithdrawalsPostExecute(r ApiWithdrawalsPostRequest) (*WithdrawalsPost201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WithdrawalsPost201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.WithdrawalsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/withdrawals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xChangeAddress == nil {
		return localVarReturnValue, nil, reportError("xChangeAddress is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vendor.iog.marlowe-runtime.withdraw-tx-json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Change-Address", r.xChangeAddress, "")
	if r.xAddress != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Address", r.xAddress, "")
	}
	if r.xCollateralUTxO != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Collateral-UTxO", r.xCollateralUTxO, "")
	}
	// body params
	localVarPostBody = r.postWithdrawalsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWithdrawalsWithdrawalIdGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	withdrawalId string
}

func (r ApiWithdrawalsWithdrawalIdGetRequest) Execute() (*Withdrawal, *http.Response, error) {
	return r.ApiService.WithdrawalsWithdrawalIdGetExecute(r)
}

/*
WithdrawalsWithdrawalIdGet Method for WithdrawalsWithdrawalIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param withdrawalId
 @return ApiWithdrawalsWithdrawalIdGetRequest
*/
func (a *DefaultAPIService) WithdrawalsWithdrawalIdGet(ctx context.Context, withdrawalId string) ApiWithdrawalsWithdrawalIdGetRequest {
	return ApiWithdrawalsWithdrawalIdGetRequest{
		ApiService: a,
		ctx: ctx,
		withdrawalId: withdrawalId,
	}
}

// Execute executes the request
//  @return Withdrawal
func (a *DefaultAPIService) WithdrawalsWithdrawalIdGetExecute(r ApiWithdrawalsWithdrawalIdGetRequest) (*Withdrawal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Withdrawal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.WithdrawalsWithdrawalIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/withdrawals/{withdrawalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"withdrawalId"+"}", url.PathEscape(parameterValueToString(r.withdrawalId, "withdrawalId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWithdrawalsWithdrawalIdPutRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	withdrawalId string
	textEnvelope *TextEnvelope
}

func (r ApiWithdrawalsWithdrawalIdPutRequest) TextEnvelope(textEnvelope TextEnvelope) ApiWithdrawalsWithdrawalIdPutRequest {
	r.textEnvelope = &textEnvelope
	return r
}

func (r ApiWithdrawalsWithdrawalIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.WithdrawalsWithdrawalIdPutExecute(r)
}

/*
WithdrawalsWithdrawalIdPut Method for WithdrawalsWithdrawalIdPut

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param withdrawalId
 @return ApiWithdrawalsWithdrawalIdPutRequest
*/
func (a *DefaultAPIService) WithdrawalsWithdrawalIdPut(ctx context.Context, withdrawalId string) ApiWithdrawalsWithdrawalIdPutRequest {
	return ApiWithdrawalsWithdrawalIdPutRequest{
		ApiService: a,
		ctx: ctx,
		withdrawalId: withdrawalId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) WithdrawalsWithdrawalIdPutExecute(r ApiWithdrawalsWithdrawalIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.WithdrawalsWithdrawalIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/withdrawals/{withdrawalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"withdrawalId"+"}", url.PathEscape(parameterValueToString(r.withdrawalId, "withdrawalId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.textEnvelope
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
