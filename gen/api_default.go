/*
Marlowe Runtime REST API

REST API for Marlowe Runtime

API version: 0.0.5.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type DefaultAPI interface {

	/*
	ApplyInputsToContract Apply inputs to contract

	Build an unsigned (Cardano) transaction body which applies inputs to an open Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId}/transactions/{transactionId} endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@return ApiApplyInputsToContractRequest
	*/
	ApplyInputsToContract(ctx context.Context, contractId string) ApiApplyInputsToContractRequest

	// ApplyInputsToContractExecute executes the request
	//  @return ApplyInputsResponse
	ApplyInputsToContractExecute(r ApiApplyInputsToContractRequest) (*ApplyInputsResponse, *http.Response, error)

	/*
	CreateContract Create a new contract

	Build an unsigned (Cardano) transaction body which opens a new Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId} endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateContractRequest
	*/
	CreateContract(ctx context.Context) ApiCreateContractRequest

	// CreateContractExecute executes the request
	//  @return CreateContractResponse
	CreateContractExecute(r ApiCreateContractRequest) (*CreateContractResponse, *http.Response, error)

	/*
	CreateContractSources Upload contract sources

	Upload a bundle of marlowe objects as contract sources. This API supports request body streaming, with newline framing between request bundles.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateContractSourcesRequest
	*/
	CreateContractSources(ctx context.Context) ApiCreateContractSourcesRequest

	// CreateContractSourcesExecute executes the request
	//  @return PostContractSourceResponse
	CreateContractSourcesExecute(r ApiCreateContractSourcesRequest) (*PostContractSourceResponse, *http.Response, error)

	/*
	GetContractById Get contract by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@return ApiGetContractByIdRequest
	*/
	GetContractById(ctx context.Context, contractId string) ApiGetContractByIdRequest

	// GetContractByIdExecute executes the request
	//  @return GetContractResponse
	GetContractByIdExecute(r ApiGetContractByIdRequest) (*GetContractResponse, *http.Response, error)

	/*
	GetContractSourceAdjacency Get adjacent contract source IDs by ID

	Get the contract source IDs which are adjacent to a contract source (they appear directly in the contract source).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractSourceId
	@return ApiGetContractSourceAdjacencyRequest
	*/
	GetContractSourceAdjacency(ctx context.Context, contractSourceId string) ApiGetContractSourceAdjacencyRequest

	// GetContractSourceAdjacencyExecute executes the request
	//  @return ContractSourceIds
	GetContractSourceAdjacencyExecute(r ApiGetContractSourceAdjacencyRequest) (*ContractSourceIds, *http.Response, error)

	/*
	GetContractSourceById Get contract source by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractSourceId
	@return ApiGetContractSourceByIdRequest
	*/
	GetContractSourceById(ctx context.Context, contractSourceId string) ApiGetContractSourceByIdRequest

	// GetContractSourceByIdExecute executes the request
	//  @return Contract
	GetContractSourceByIdExecute(r ApiGetContractSourceByIdRequest) (*Contract, *http.Response, error)

	/*
	GetContractSourceClosure Get contract source closure by ID

	Get the contract source IDs which appear in the full hierarchy of a contract source (including the ID of the contract source its self).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractSourceId
	@return ApiGetContractSourceClosureRequest
	*/
	GetContractSourceClosure(ctx context.Context, contractSourceId string) ApiGetContractSourceClosureRequest

	// GetContractSourceClosureExecute executes the request
	//  @return ContractSourceIds
	GetContractSourceClosureExecute(r ApiGetContractSourceClosureRequest) (*ContractSourceIds, *http.Response, error)

	/*
	GetContractTransactionById Get contract transaction by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@param transactionId
	@return ApiGetContractTransactionByIdRequest
	*/
	GetContractTransactionById(ctx context.Context, contractId string, transactionId string) ApiGetContractTransactionByIdRequest

	// GetContractTransactionByIdExecute executes the request
	//  @return GetTransactionResponse
	GetContractTransactionByIdExecute(r ApiGetContractTransactionByIdRequest) (*GetTransactionResponse, *http.Response, error)

	/*
	GetContracts Get contracts

	Get contracts published on chain. Results are returned in pages, with paging being specified by request headers.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetContractsRequest
	*/
	GetContracts(ctx context.Context) ApiGetContractsRequest

	// GetContractsExecute executes the request
	//  @return GetContractsResponse
	GetContractsExecute(r ApiGetContractsRequest) (*GetContractsResponse, *http.Response, error)

	/*
	GetNextStepsForContract Get next contract steps

	Get inputs which could be performed on a contract withing a time range by the requested parties.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@return ApiGetNextStepsForContractRequest
	*/
	GetNextStepsForContract(ctx context.Context, contractId string) ApiGetNextStepsForContractRequest

	// GetNextStepsForContractExecute executes the request
	//  @return Next
	GetNextStepsForContractExecute(r ApiGetNextStepsForContractRequest) (*Next, *http.Response, error)

	/*
	GetPayoutById Get payout by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param payoutId
	@return ApiGetPayoutByIdRequest
	*/
	GetPayoutById(ctx context.Context, payoutId string) ApiGetPayoutByIdRequest

	// GetPayoutByIdExecute executes the request
	//  @return GetPayoutResponse
	GetPayoutByIdExecute(r ApiGetPayoutByIdRequest) (*GetPayoutResponse, *http.Response, error)

	/*
	GetPayouts Get role payouts

	Get payouts to parties from role-based contracts. Results are returned in pages, with paging being specified by request headers.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetPayoutsRequest
	*/
	GetPayouts(ctx context.Context) ApiGetPayoutsRequest

	// GetPayoutsExecute executes the request
	//  @return GetPayoutsResponse
	GetPayoutsExecute(r ApiGetPayoutsRequest) (*GetPayoutsResponse, *http.Response, error)

	/*
	GetTransactionsForContract Get transactions for contract

	Get published transactions for a contract. Results are returned in pages, with paging being specified by request headers.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@return ApiGetTransactionsForContractRequest
	*/
	GetTransactionsForContract(ctx context.Context, contractId string) ApiGetTransactionsForContractRequest

	// GetTransactionsForContractExecute executes the request
	//  @return GetTransactionsResponse
	GetTransactionsForContractExecute(r ApiGetTransactionsForContractRequest) (*GetTransactionsResponse, *http.Response, error)

	/*
	GetWithdrawalById Get withdrawal by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param withdrawalId
	@return ApiGetWithdrawalByIdRequest
	*/
	GetWithdrawalById(ctx context.Context, withdrawalId string) ApiGetWithdrawalByIdRequest

	// GetWithdrawalByIdExecute executes the request
	//  @return Withdrawal
	GetWithdrawalByIdExecute(r ApiGetWithdrawalByIdRequest) (*Withdrawal, *http.Response, error)

	/*
	GetWithdrawals Get withdrawals

	Get published withdrawal transactions. Results are returned in pages, with paging being specified by request headers.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetWithdrawalsRequest
	*/
	GetWithdrawals(ctx context.Context) ApiGetWithdrawalsRequest

	// GetWithdrawalsExecute executes the request
	//  @return GetWithdrawalsResponse
	GetWithdrawalsExecute(r ApiGetWithdrawalsRequest) (*GetWithdrawalsResponse, *http.Response, error)

	/*
	Healthcheck Test server status

	Check if the server is running and ready to respond to requests.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiHealthcheckRequest
	*/
	Healthcheck(ctx context.Context) ApiHealthcheckRequest

	// HealthcheckExecute executes the request
	HealthcheckExecute(r ApiHealthcheckRequest) (*http.Response, error)

	/*
	SubmitContract Submit contract to chain

	Submit a signed (Cardano) transaction that opens a new Marlowe contract. The transaction must have originally been created by the POST /contracts endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId} endpoint to poll the on-chain status.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@return ApiSubmitContractRequest
	*/
	SubmitContract(ctx context.Context, contractId string) ApiSubmitContractRequest

	// SubmitContractExecute executes the request
	SubmitContractExecute(r ApiSubmitContractRequest) (*http.Response, error)

	/*
	SubmitContractTransaction Submit contract input application

	Submit a signed (Cardano) transaction that applies inputs to an open Marlowe contract. The transaction must have originally been created by the POST /contracts/{contractId}/transactions endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId}/transactions/{transactionId} endpoint to poll the on-chain status.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contractId
	@param transactionId
	@return ApiSubmitContractTransactionRequest
	*/
	SubmitContractTransaction(ctx context.Context, contractId string, transactionId string) ApiSubmitContractTransactionRequest

	// SubmitContractTransactionExecute executes the request
	SubmitContractTransactionExecute(r ApiSubmitContractTransactionRequest) (*http.Response, error)

	/*
	SubmitWithdrawal Submit payout withdrawal

	Submit a signed (Cardano) transaction that withdraws available payouts from a role payout validator. The transaction must have originally been created by the POST /withdrawals endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /withdrawals/{withdrawalId} endpoint to poll the on-chain status.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param withdrawalId
	@return ApiSubmitWithdrawalRequest
	*/
	SubmitWithdrawal(ctx context.Context, withdrawalId string) ApiSubmitWithdrawalRequest

	// SubmitWithdrawalExecute executes the request
	SubmitWithdrawalExecute(r ApiSubmitWithdrawalRequest) (*http.Response, error)

	/*
	WithdrawPayouts Withdraw payouts

	Build an unsigned (Cardano) transaction body which withdraws available payouts from a role payout validator. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /withdrawals/{withdrawalId} endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWithdrawPayoutsRequest
	*/
	WithdrawPayouts(ctx context.Context) ApiWithdrawPayoutsRequest

	// WithdrawPayoutsExecute executes the request
	//  @return WithdrawPayoutsResponse
	WithdrawPayoutsExecute(r ApiWithdrawPayoutsRequest) (*WithdrawPayoutsResponse, *http.Response, error)
}

// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiApplyInputsToContractRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractId string
	xChangeAddress *string
	xAddress *string
	xCollateralUTxO *string
	postTransactionsRequest *PostTransactionsRequest
}

func (r ApiApplyInputsToContractRequest) XChangeAddress(xChangeAddress string) ApiApplyInputsToContractRequest {
	r.xChangeAddress = &xChangeAddress
	return r
}

func (r ApiApplyInputsToContractRequest) XAddress(xAddress string) ApiApplyInputsToContractRequest {
	r.xAddress = &xAddress
	return r
}

func (r ApiApplyInputsToContractRequest) XCollateralUTxO(xCollateralUTxO string) ApiApplyInputsToContractRequest {
	r.xCollateralUTxO = &xCollateralUTxO
	return r
}

func (r ApiApplyInputsToContractRequest) PostTransactionsRequest(postTransactionsRequest PostTransactionsRequest) ApiApplyInputsToContractRequest {
	r.postTransactionsRequest = &postTransactionsRequest
	return r
}

func (r ApiApplyInputsToContractRequest) Execute() (*ApplyInputsResponse, *http.Response, error) {
	return r.ApiService.ApplyInputsToContractExecute(r)
}

/*
ApplyInputsToContract Apply inputs to contract

Build an unsigned (Cardano) transaction body which applies inputs to an open Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId}/transactions/{transactionId} endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @return ApiApplyInputsToContractRequest
*/
func (a *DefaultAPIService) ApplyInputsToContract(ctx context.Context, contractId string) ApiApplyInputsToContractRequest {
	return ApiApplyInputsToContractRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
	}
}

// Execute executes the request
//  @return ApplyInputsResponse
func (a *DefaultAPIService) ApplyInputsToContractExecute(r ApiApplyInputsToContractRequest) (*ApplyInputsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplyInputsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApplyInputsToContract")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contractId}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xChangeAddress == nil {
		return localVarReturnValue, nil, reportError("xChangeAddress is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vendor.iog.marlowe-runtime.apply-inputs-tx-json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Change-Address", r.xChangeAddress, "")
	if r.xAddress != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Address", r.xAddress, "")
	}
	if r.xCollateralUTxO != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Collateral-UTxO", r.xCollateralUTxO, "")
	}
	// body params
	localVarPostBody = r.postTransactionsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateContractRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	xChangeAddress *string
	xStakeAddress *string
	xAddress *string
	xCollateralUTxO *string
	postContractsRequest *PostContractsRequest
}

func (r ApiCreateContractRequest) XChangeAddress(xChangeAddress string) ApiCreateContractRequest {
	r.xChangeAddress = &xChangeAddress
	return r
}

// Where to send staking rewards for the Marlowe script outputs of this contract.
func (r ApiCreateContractRequest) XStakeAddress(xStakeAddress string) ApiCreateContractRequest {
	r.xStakeAddress = &xStakeAddress
	return r
}

func (r ApiCreateContractRequest) XAddress(xAddress string) ApiCreateContractRequest {
	r.xAddress = &xAddress
	return r
}

func (r ApiCreateContractRequest) XCollateralUTxO(xCollateralUTxO string) ApiCreateContractRequest {
	r.xCollateralUTxO = &xCollateralUTxO
	return r
}

func (r ApiCreateContractRequest) PostContractsRequest(postContractsRequest PostContractsRequest) ApiCreateContractRequest {
	r.postContractsRequest = &postContractsRequest
	return r
}

func (r ApiCreateContractRequest) Execute() (*CreateContractResponse, *http.Response, error) {
	return r.ApiService.CreateContractExecute(r)
}

/*
CreateContract Create a new contract

Build an unsigned (Cardano) transaction body which opens a new Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId} endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateContractRequest
*/
func (a *DefaultAPIService) CreateContract(ctx context.Context) ApiCreateContractRequest {
	return ApiCreateContractRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateContractResponse
func (a *DefaultAPIService) CreateContractExecute(r ApiCreateContractRequest) (*CreateContractResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateContractResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateContract")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xChangeAddress == nil {
		return localVarReturnValue, nil, reportError("xChangeAddress is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vendor.iog.marlowe-runtime.contract-tx-json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xStakeAddress != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Stake-Address", r.xStakeAddress, "")
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Change-Address", r.xChangeAddress, "")
	if r.xAddress != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Address", r.xAddress, "")
	}
	if r.xCollateralUTxO != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Collateral-UTxO", r.xCollateralUTxO, "")
	}
	// body params
	localVarPostBody = r.postContractsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateContractSourcesRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	main *string
	labelledObject *[]LabelledObject
}

// The label of the top-level contract object in the bundle(s).
func (r ApiCreateContractSourcesRequest) Main(main string) ApiCreateContractSourcesRequest {
	r.main = &main
	return r
}

func (r ApiCreateContractSourcesRequest) LabelledObject(labelledObject []LabelledObject) ApiCreateContractSourcesRequest {
	r.labelledObject = &labelledObject
	return r
}

func (r ApiCreateContractSourcesRequest) Execute() (*PostContractSourceResponse, *http.Response, error) {
	return r.ApiService.CreateContractSourcesExecute(r)
}

/*
CreateContractSources Upload contract sources

Upload a bundle of marlowe objects as contract sources. This API supports request body streaming, with newline framing between request bundles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateContractSourcesRequest
*/
func (a *DefaultAPIService) CreateContractSources(ctx context.Context) ApiCreateContractSourcesRequest {
	return ApiCreateContractSourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostContractSourceResponse
func (a *DefaultAPIService) CreateContractSourcesExecute(r ApiCreateContractSourcesRequest) (*PostContractSourceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostContractSourceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateContractSources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/sources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.main == nil {
		return localVarReturnValue, nil, reportError("main is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "main", r.main, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.labelledObject
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractByIdRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractId string
}

func (r ApiGetContractByIdRequest) Execute() (*GetContractResponse, *http.Response, error) {
	return r.ApiService.GetContractByIdExecute(r)
}

/*
GetContractById Get contract by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @return ApiGetContractByIdRequest
*/
func (a *DefaultAPIService) GetContractById(ctx context.Context, contractId string) ApiGetContractByIdRequest {
	return ApiGetContractByIdRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
	}
}

// Execute executes the request
//  @return GetContractResponse
func (a *DefaultAPIService) GetContractByIdExecute(r ApiGetContractByIdRequest) (*GetContractResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetContractResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetContractById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contractId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractSourceAdjacencyRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractSourceId string
}

func (r ApiGetContractSourceAdjacencyRequest) Execute() (*ContractSourceIds, *http.Response, error) {
	return r.ApiService.GetContractSourceAdjacencyExecute(r)
}

/*
GetContractSourceAdjacency Get adjacent contract source IDs by ID

Get the contract source IDs which are adjacent to a contract source (they appear directly in the contract source).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractSourceId
 @return ApiGetContractSourceAdjacencyRequest
*/
func (a *DefaultAPIService) GetContractSourceAdjacency(ctx context.Context, contractSourceId string) ApiGetContractSourceAdjacencyRequest {
	return ApiGetContractSourceAdjacencyRequest{
		ApiService: a,
		ctx: ctx,
		contractSourceId: contractSourceId,
	}
}

// Execute executes the request
//  @return ContractSourceIds
func (a *DefaultAPIService) GetContractSourceAdjacencyExecute(r ApiGetContractSourceAdjacencyRequest) (*ContractSourceIds, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractSourceIds
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetContractSourceAdjacency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/sources/{contractSourceId}/adjacency"
	localVarPath = strings.Replace(localVarPath, "{"+"contractSourceId"+"}", url.PathEscape(parameterValueToString(r.contractSourceId, "contractSourceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractSourceByIdRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractSourceId string
	expand *bool
}

func (r ApiGetContractSourceByIdRequest) Expand(expand bool) ApiGetContractSourceByIdRequest {
	r.expand = &expand
	return r
}

func (r ApiGetContractSourceByIdRequest) Execute() (*Contract, *http.Response, error) {
	return r.ApiService.GetContractSourceByIdExecute(r)
}

/*
GetContractSourceById Get contract source by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractSourceId
 @return ApiGetContractSourceByIdRequest
*/
func (a *DefaultAPIService) GetContractSourceById(ctx context.Context, contractSourceId string) ApiGetContractSourceByIdRequest {
	return ApiGetContractSourceByIdRequest{
		ApiService: a,
		ctx: ctx,
		contractSourceId: contractSourceId,
	}
}

// Execute executes the request
//  @return Contract
func (a *DefaultAPIService) GetContractSourceByIdExecute(r ApiGetContractSourceByIdRequest) (*Contract, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Contract
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetContractSourceById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/sources/{contractSourceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contractSourceId"+"}", url.PathEscape(parameterValueToString(r.contractSourceId, "contractSourceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "")
	} else {
		var defaultValue bool = false
		r.expand = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractSourceClosureRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractSourceId string
}

func (r ApiGetContractSourceClosureRequest) Execute() (*ContractSourceIds, *http.Response, error) {
	return r.ApiService.GetContractSourceClosureExecute(r)
}

/*
GetContractSourceClosure Get contract source closure by ID

Get the contract source IDs which appear in the full hierarchy of a contract source (including the ID of the contract source its self).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractSourceId
 @return ApiGetContractSourceClosureRequest
*/
func (a *DefaultAPIService) GetContractSourceClosure(ctx context.Context, contractSourceId string) ApiGetContractSourceClosureRequest {
	return ApiGetContractSourceClosureRequest{
		ApiService: a,
		ctx: ctx,
		contractSourceId: contractSourceId,
	}
}

// Execute executes the request
//  @return ContractSourceIds
func (a *DefaultAPIService) GetContractSourceClosureExecute(r ApiGetContractSourceClosureRequest) (*ContractSourceIds, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContractSourceIds
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetContractSourceClosure")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/sources/{contractSourceId}/closure"
	localVarPath = strings.Replace(localVarPath, "{"+"contractSourceId"+"}", url.PathEscape(parameterValueToString(r.contractSourceId, "contractSourceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractTransactionByIdRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractId string
	transactionId string
}

func (r ApiGetContractTransactionByIdRequest) Execute() (*GetTransactionResponse, *http.Response, error) {
	return r.ApiService.GetContractTransactionByIdExecute(r)
}

/*
GetContractTransactionById Get contract transaction by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @param transactionId
 @return ApiGetContractTransactionByIdRequest
*/
func (a *DefaultAPIService) GetContractTransactionById(ctx context.Context, contractId string, transactionId string) ApiGetContractTransactionByIdRequest {
	return ApiGetContractTransactionByIdRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
		transactionId: transactionId,
	}
}

// Execute executes the request
//  @return GetTransactionResponse
func (a *DefaultAPIService) GetContractTransactionByIdExecute(r ApiGetContractTransactionByIdRequest) (*GetTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetContractTransactionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contractId}/transactions/{transactionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	roleCurrency *[]string
	tag *[]string
	partyAddress *[]string
	partyRole *[]string
	range_ *string
}

func (r ApiGetContractsRequest) RoleCurrency(roleCurrency []string) ApiGetContractsRequest {
	r.roleCurrency = &roleCurrency
	return r
}

func (r ApiGetContractsRequest) Tag(tag []string) ApiGetContractsRequest {
	r.tag = &tag
	return r
}

func (r ApiGetContractsRequest) PartyAddress(partyAddress []string) ApiGetContractsRequest {
	r.partyAddress = &partyAddress
	return r
}

func (r ApiGetContractsRequest) PartyRole(partyRole []string) ApiGetContractsRequest {
	r.partyRole = &partyRole
	return r
}

func (r ApiGetContractsRequest) Range_(range_ string) ApiGetContractsRequest {
	r.range_ = &range_
	return r
}

func (r ApiGetContractsRequest) Execute() (*GetContractsResponse, *http.Response, error) {
	return r.ApiService.GetContractsExecute(r)
}

/*
GetContracts Get contracts

Get contracts published on chain. Results are returned in pages, with paging being specified by request headers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetContractsRequest
*/
func (a *DefaultAPIService) GetContracts(ctx context.Context) ApiGetContractsRequest {
	return ApiGetContractsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetContractsResponse
func (a *DefaultAPIService) GetContractsExecute(r ApiGetContractsRequest) (*GetContractsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetContractsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetContracts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.roleCurrency != nil {
		t := *r.roleCurrency
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roleCurrency", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roleCurrency", t, "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.partyAddress != nil {
		t := *r.partyAddress
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "partyAddress", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "partyAddress", t, "multi")
		}
	}
	if r.partyRole != nil {
		t := *r.partyRole
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "partyRole", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "partyRole", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Range", r.range_, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNextStepsForContractRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractId string
	validityStart *string
	validityEnd *string
	party *[]string
}

// The beginning of the validity range.
func (r ApiGetNextStepsForContractRequest) ValidityStart(validityStart string) ApiGetNextStepsForContractRequest {
	r.validityStart = &validityStart
	return r
}

// The end of the validity range.
func (r ApiGetNextStepsForContractRequest) ValidityEnd(validityEnd string) ApiGetNextStepsForContractRequest {
	r.validityEnd = &validityEnd
	return r
}

func (r ApiGetNextStepsForContractRequest) Party(party []string) ApiGetNextStepsForContractRequest {
	r.party = &party
	return r
}

func (r ApiGetNextStepsForContractRequest) Execute() (*Next, *http.Response, error) {
	return r.ApiService.GetNextStepsForContractExecute(r)
}

/*
GetNextStepsForContract Get next contract steps

Get inputs which could be performed on a contract withing a time range by the requested parties.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @return ApiGetNextStepsForContractRequest
*/
func (a *DefaultAPIService) GetNextStepsForContract(ctx context.Context, contractId string) ApiGetNextStepsForContractRequest {
	return ApiGetNextStepsForContractRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
	}
}

// Execute executes the request
//  @return Next
func (a *DefaultAPIService) GetNextStepsForContractExecute(r ApiGetNextStepsForContractRequest) (*Next, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Next
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetNextStepsForContract")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contractId}/next"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.validityStart == nil {
		return localVarReturnValue, nil, reportError("validityStart is required and must be specified")
	}
	if r.validityEnd == nil {
		return localVarReturnValue, nil, reportError("validityEnd is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "validityStart", r.validityStart, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "validityEnd", r.validityEnd, "")
	if r.party != nil {
		t := *r.party
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "party", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "party", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPayoutByIdRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	payoutId string
}

func (r ApiGetPayoutByIdRequest) Execute() (*GetPayoutResponse, *http.Response, error) {
	return r.ApiService.GetPayoutByIdExecute(r)
}

/*
GetPayoutById Get payout by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param payoutId
 @return ApiGetPayoutByIdRequest
*/
func (a *DefaultAPIService) GetPayoutById(ctx context.Context, payoutId string) ApiGetPayoutByIdRequest {
	return ApiGetPayoutByIdRequest{
		ApiService: a,
		ctx: ctx,
		payoutId: payoutId,
	}
}

// Execute executes the request
//  @return GetPayoutResponse
func (a *DefaultAPIService) GetPayoutByIdExecute(r ApiGetPayoutByIdRequest) (*GetPayoutResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPayoutResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetPayoutById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts/{payoutId}"
	localVarPath = strings.Replace(localVarPath, "{"+"payoutId"+"}", url.PathEscape(parameterValueToString(r.payoutId, "payoutId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPayoutsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractId *[]string
	roleToken *[]string
	status *string
	range_ *string
}

func (r ApiGetPayoutsRequest) ContractId(contractId []string) ApiGetPayoutsRequest {
	r.contractId = &contractId
	return r
}

func (r ApiGetPayoutsRequest) RoleToken(roleToken []string) ApiGetPayoutsRequest {
	r.roleToken = &roleToken
	return r
}

// Whether to include available or withdrawn payouts in the results.
func (r ApiGetPayoutsRequest) Status(status string) ApiGetPayoutsRequest {
	r.status = &status
	return r
}

func (r ApiGetPayoutsRequest) Range_(range_ string) ApiGetPayoutsRequest {
	r.range_ = &range_
	return r
}

func (r ApiGetPayoutsRequest) Execute() (*GetPayoutsResponse, *http.Response, error) {
	return r.ApiService.GetPayoutsExecute(r)
}

/*
GetPayouts Get role payouts

Get payouts to parties from role-based contracts. Results are returned in pages, with paging being specified by request headers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPayoutsRequest
*/
func (a *DefaultAPIService) GetPayouts(ctx context.Context) ApiGetPayoutsRequest {
	return ApiGetPayoutsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPayoutsResponse
func (a *DefaultAPIService) GetPayoutsExecute(r ApiGetPayoutsRequest) (*GetPayoutsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPayoutsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetPayouts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contractId != nil {
		t := *r.contractId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contractId", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contractId", t, "multi")
		}
	}
	if r.roleToken != nil {
		t := *r.roleToken
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roleToken", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roleToken", t, "multi")
		}
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Range", r.range_, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionsForContractRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractId string
	range_ *string
}

func (r ApiGetTransactionsForContractRequest) Range_(range_ string) ApiGetTransactionsForContractRequest {
	r.range_ = &range_
	return r
}

func (r ApiGetTransactionsForContractRequest) Execute() (*GetTransactionsResponse, *http.Response, error) {
	return r.ApiService.GetTransactionsForContractExecute(r)
}

/*
GetTransactionsForContract Get transactions for contract

Get published transactions for a contract. Results are returned in pages, with paging being specified by request headers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @return ApiGetTransactionsForContractRequest
*/
func (a *DefaultAPIService) GetTransactionsForContract(ctx context.Context, contractId string) ApiGetTransactionsForContractRequest {
	return ApiGetTransactionsForContractRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
	}
}

// Execute executes the request
//  @return GetTransactionsResponse
func (a *DefaultAPIService) GetTransactionsForContractExecute(r ApiGetTransactionsForContractRequest) (*GetTransactionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTransactionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetTransactionsForContract")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contractId}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Range", r.range_, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWithdrawalByIdRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	withdrawalId string
}

func (r ApiGetWithdrawalByIdRequest) Execute() (*Withdrawal, *http.Response, error) {
	return r.ApiService.GetWithdrawalByIdExecute(r)
}

/*
GetWithdrawalById Get withdrawal by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param withdrawalId
 @return ApiGetWithdrawalByIdRequest
*/
func (a *DefaultAPIService) GetWithdrawalById(ctx context.Context, withdrawalId string) ApiGetWithdrawalByIdRequest {
	return ApiGetWithdrawalByIdRequest{
		ApiService: a,
		ctx: ctx,
		withdrawalId: withdrawalId,
	}
}

// Execute executes the request
//  @return Withdrawal
func (a *DefaultAPIService) GetWithdrawalByIdExecute(r ApiGetWithdrawalByIdRequest) (*Withdrawal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Withdrawal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetWithdrawalById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/withdrawals/{withdrawalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"withdrawalId"+"}", url.PathEscape(parameterValueToString(r.withdrawalId, "withdrawalId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWithdrawalsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	roleCurrency *[]string
	range_ *string
}

func (r ApiGetWithdrawalsRequest) RoleCurrency(roleCurrency []string) ApiGetWithdrawalsRequest {
	r.roleCurrency = &roleCurrency
	return r
}

func (r ApiGetWithdrawalsRequest) Range_(range_ string) ApiGetWithdrawalsRequest {
	r.range_ = &range_
	return r
}

func (r ApiGetWithdrawalsRequest) Execute() (*GetWithdrawalsResponse, *http.Response, error) {
	return r.ApiService.GetWithdrawalsExecute(r)
}

/*
GetWithdrawals Get withdrawals

Get published withdrawal transactions. Results are returned in pages, with paging being specified by request headers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetWithdrawalsRequest
*/
func (a *DefaultAPIService) GetWithdrawals(ctx context.Context) ApiGetWithdrawalsRequest {
	return ApiGetWithdrawalsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetWithdrawalsResponse
func (a *DefaultAPIService) GetWithdrawalsExecute(r ApiGetWithdrawalsRequest) (*GetWithdrawalsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetWithdrawalsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetWithdrawals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/withdrawals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.roleCurrency != nil {
		t := *r.roleCurrency
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roleCurrency", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roleCurrency", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Range", r.range_, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHealthcheckRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiHealthcheckRequest) Execute() (*http.Response, error) {
	return r.ApiService.HealthcheckExecute(r)
}

/*
Healthcheck Test server status

Check if the server is running and ready to respond to requests.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHealthcheckRequest
*/
func (a *DefaultAPIService) Healthcheck(ctx context.Context) ApiHealthcheckRequest {
	return ApiHealthcheckRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) HealthcheckExecute(r ApiHealthcheckRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.Healthcheck")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/healthcheck"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSubmitContractRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractId string
	textEnvelope *TextEnvelope
}

func (r ApiSubmitContractRequest) TextEnvelope(textEnvelope TextEnvelope) ApiSubmitContractRequest {
	r.textEnvelope = &textEnvelope
	return r
}

func (r ApiSubmitContractRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubmitContractExecute(r)
}

/*
SubmitContract Submit contract to chain

Submit a signed (Cardano) transaction that opens a new Marlowe contract. The transaction must have originally been created by the POST /contracts endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId} endpoint to poll the on-chain status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @return ApiSubmitContractRequest
*/
func (a *DefaultAPIService) SubmitContract(ctx context.Context, contractId string) ApiSubmitContractRequest {
	return ApiSubmitContractRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SubmitContractExecute(r ApiSubmitContractRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SubmitContract")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contractId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.textEnvelope
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSubmitContractTransactionRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	contractId string
	transactionId string
	textEnvelope *TextEnvelope
}

func (r ApiSubmitContractTransactionRequest) TextEnvelope(textEnvelope TextEnvelope) ApiSubmitContractTransactionRequest {
	r.textEnvelope = &textEnvelope
	return r
}

func (r ApiSubmitContractTransactionRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubmitContractTransactionExecute(r)
}

/*
SubmitContractTransaction Submit contract input application

Submit a signed (Cardano) transaction that applies inputs to an open Marlowe contract. The transaction must have originally been created by the POST /contracts/{contractId}/transactions endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId}/transactions/{transactionId} endpoint to poll the on-chain status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contractId
 @param transactionId
 @return ApiSubmitContractTransactionRequest
*/
func (a *DefaultAPIService) SubmitContractTransaction(ctx context.Context, contractId string, transactionId string) ApiSubmitContractTransactionRequest {
	return ApiSubmitContractTransactionRequest{
		ApiService: a,
		ctx: ctx,
		contractId: contractId,
		transactionId: transactionId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SubmitContractTransactionExecute(r ApiSubmitContractTransactionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SubmitContractTransaction")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contractId}/transactions/{transactionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contractId"+"}", url.PathEscape(parameterValueToString(r.contractId, "contractId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.textEnvelope
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSubmitWithdrawalRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	withdrawalId string
	textEnvelope *TextEnvelope
}

func (r ApiSubmitWithdrawalRequest) TextEnvelope(textEnvelope TextEnvelope) ApiSubmitWithdrawalRequest {
	r.textEnvelope = &textEnvelope
	return r
}

func (r ApiSubmitWithdrawalRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubmitWithdrawalExecute(r)
}

/*
SubmitWithdrawal Submit payout withdrawal

Submit a signed (Cardano) transaction that withdraws available payouts from a role payout validator. The transaction must have originally been created by the POST /withdrawals endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /withdrawals/{withdrawalId} endpoint to poll the on-chain status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param withdrawalId
 @return ApiSubmitWithdrawalRequest
*/
func (a *DefaultAPIService) SubmitWithdrawal(ctx context.Context, withdrawalId string) ApiSubmitWithdrawalRequest {
	return ApiSubmitWithdrawalRequest{
		ApiService: a,
		ctx: ctx,
		withdrawalId: withdrawalId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SubmitWithdrawalExecute(r ApiSubmitWithdrawalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SubmitWithdrawal")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/withdrawals/{withdrawalId}"
	localVarPath = strings.Replace(localVarPath, "{"+"withdrawalId"+"}", url.PathEscape(parameterValueToString(r.withdrawalId, "withdrawalId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.textEnvelope
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWithdrawPayoutsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	xChangeAddress *string
	xAddress *string
	xCollateralUTxO *string
	postWithdrawalsRequest *PostWithdrawalsRequest
}

func (r ApiWithdrawPayoutsRequest) XChangeAddress(xChangeAddress string) ApiWithdrawPayoutsRequest {
	r.xChangeAddress = &xChangeAddress
	return r
}

func (r ApiWithdrawPayoutsRequest) XAddress(xAddress string) ApiWithdrawPayoutsRequest {
	r.xAddress = &xAddress
	return r
}

func (r ApiWithdrawPayoutsRequest) XCollateralUTxO(xCollateralUTxO string) ApiWithdrawPayoutsRequest {
	r.xCollateralUTxO = &xCollateralUTxO
	return r
}

func (r ApiWithdrawPayoutsRequest) PostWithdrawalsRequest(postWithdrawalsRequest PostWithdrawalsRequest) ApiWithdrawPayoutsRequest {
	r.postWithdrawalsRequest = &postWithdrawalsRequest
	return r
}

func (r ApiWithdrawPayoutsRequest) Execute() (*WithdrawPayoutsResponse, *http.Response, error) {
	return r.ApiService.WithdrawPayoutsExecute(r)
}

/*
WithdrawPayouts Withdraw payouts

Build an unsigned (Cardano) transaction body which withdraws available payouts from a role payout validator. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /withdrawals/{withdrawalId} endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWithdrawPayoutsRequest
*/
func (a *DefaultAPIService) WithdrawPayouts(ctx context.Context) ApiWithdrawPayoutsRequest {
	return ApiWithdrawPayoutsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WithdrawPayoutsResponse
func (a *DefaultAPIService) WithdrawPayoutsExecute(r ApiWithdrawPayoutsRequest) (*WithdrawPayoutsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WithdrawPayoutsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.WithdrawPayouts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/withdrawals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xChangeAddress == nil {
		return localVarReturnValue, nil, reportError("xChangeAddress is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vendor.iog.marlowe-runtime.withdraw-tx-json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Change-Address", r.xChangeAddress, "")
	if r.xAddress != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Address", r.xAddress, "")
	}
	if r.xCollateralUTxO != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Collateral-UTxO", r.xCollateralUTxO, "")
	}
	// body params
	localVarPostBody = r.postWithdrawalsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
